#### Solution_101.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_101
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_101 {
    public boolean isSymmetric(TreeNode root) {
        if (root==null){
            return true;
        }
        else {
            return isCore(root.left,root.right);
        }
    }
    public boolean isCore(TreeNode left,TreeNode right) {
        if (left==null&&right==null){
            return true;
        }
        else if (left==null||right==null){
            return false;
        }
        else {
            if (left.val!=right.val){
                return false;
            }
            return isCore(left.left,right.right)&&isCore(left.right,right.left);
        }
    }


}
```
#### Solution_107.java
```java
package 数据结构相关.树;

import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_107
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_107 {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> lists = new LinkedList<>();
        if (root==null){
            return lists;
        }
        LinkedList <TreeNode> list = new LinkedList<>();
        list.add(root);
        while (!list.isEmpty()){
            int size = list.size();
            LinkedList <Integer> temp = new LinkedList<>();
            while (size>=0){
                TreeNode remove = list.remove(0);
                if (remove.left!=null){
                    list.add(remove.left);
                }
                if (remove.right!=null){
                    list.add(remove.right);
                }
                temp.add(remove.val);
                size--;
            }
            lists.add(0,temp);
        }
        return lists;
    }
}
```
#### Solution_110.java
```java
package 数据结构相关.树;

public class Solution_110 {
    public boolean isBalanced(TreeNode root) {
        if (root==null){
            return true;
        }
        else {
            if (isBalanced(root.right)&&isBalanced(root.left)&&Math.abs(deep(root.right)-deep(root.left))<=1){
                return true;
            }
            return false;
        }
    }
    public int deep(TreeNode root){
        if (root==null){
            return 0;
        }
        else{
            return 1+Math.max(deep(root.right),deep(root.left));
        }
    }




    ///////////第二种
    private boolean result = true;

    public boolean isBalanced2(TreeNode root) {
        maxDepth(root);
        return result;
    }

    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if (Math.abs(l - r) > 1) result = false;
        return 1 + Math.max(l, r);
    }
}
```
#### Solution_111.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_111
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_111 {
    public int minDepth(TreeNode root) {
        if (root == null ){
            return 0;
        }
        if(root.left==null&&root.right==null){
            return 1;
        }
        if (root.left==null&&root.right!=null){
            return 1+minDepth(root.right);
        }
        else if (root.left!=null&&root.right==null){
            return 1+minDepth(root.left);
        }
        else {
            return 1+Math.min(minDepth(root.right),minDepth(root.left));
        }
    }
}
```
#### Solution_112.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_112
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_112 {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root==null){
            return false;
        }
        else if (root.left==null&&root.right==null){
            if (sum == root.val){
                return true;
            }
            return false;
        }
        else {
            return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
        }
    }
}
```
#### Solution_337.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_337
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_337 {
//    int i = 0;
    LinkedList<Integer> list = new LinkedList();
    public int rob(TreeNode root) {
        if (root==null){
            return 0;
        }
        else {
            int core = core(root);
        }
        return core(root);
    }
    public int core(TreeNode root) {
        if (root == null){
            return 0;
        }
        else {
            int left = core(root.left);
            int right = core(root.right);
            int k = list.isEmpty()? 0 : list.peek();
            int max = Math.max(root.val + k, left + right);
            list.add(left+right);
            return max;
        }
    }

}
```
#### Solution_404.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_404
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_404 {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root==null){
            return 0;
        }
        else {
            return sumOfLeftLeaves(root.left,0)+sumOfLeftLeaves(root.right,1);
        }
    }
    public int sumOfLeftLeaves(TreeNode root,int i) {
        if (root==null){
            return 0;
        }
        else if (root.left==null&&root.right==null){
            if (i==0){
                return root.val;
            }
            else {
                return 0;
            }
        }
        else {
            return sumOfLeftLeaves(root.left,0)+sumOfLeftLeaves(root.right,1);
        }
    }


}
```
#### Solution_437.java
```java
package 数据结构相关.树;

import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_437
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_437 {
    static  int result =0;
    public int pathSum(TreeNode root, int sum) {
        if (root==null){
            return 0;
        }
        else if (root.val == sum){
            sum++;
        }
        else if (root.val>sum){
            return 0;
        }
        pathSum(root.left,sum - root.val);
        pathSum(root.right,sum - root.val);
        pathSum(root.left,sum );
        pathSum(root.right,sum );
        return sum;
    }
}
class Solution {
    int path  = 0;
    public int pathSum(TreeNode root, int sum) {
        List<TreeNode> list =new LinkedList<>();
        list.add(root);
        while (!list.isEmpty()){
            TreeNode temp = ((LinkedList<TreeNode>) list).remove(0);
            pathSumCore(temp,sum,0);
            if (temp!=null){
                list.add(temp.left);
                list.add(temp.right);
            }
        }
        return path;
    }

    public void pathSumCore(TreeNode root ,int sum,int now){

        if (root==null){
            return ;
        }
        if (sum==(now=now+root.val)){
            now=0;
            path++;
        }

        //now = root.val+now;
        pathSumCore(root.left,sum,now);
        pathSumCore(root.right,sum,now);

    }
}
```
#### Solution_543.java
```java
package 数据结构相关.树;

import java.util.Collections;
import java.util.Vector;
import java.util.concurrent.atomic.AtomicInteger;

public class Solution_543 {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null)
            return 0;
        else {
            int temp =  deep(root.right)+deep(root.left);
            int i = diameterOfBinaryTree(root.right);
            int j = diameterOfBinaryTree(root.left);
            if (temp>i){
                return temp;
            }
            else if (i>j){
                return i;
            }
            else {
                return j;
            }
        }
    }
    public int deep(TreeNode root){
        if (root==null){
            return 0;
        }
        else{
            return 1+Math.max(deep(root.right),deep(root.left));
        }
    }










    private int max = 0;

    public int diameterOfBinaryTree2(TreeNode root) {
        depth(root);

        return max;

    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = depth(root.left);
        int rightDepth = depth(root.right);
        max = Math.max(max, leftDepth + rightDepth);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```
#### Solution_572.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_572
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/

public class Solution_572 {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (t==null){
            return true;
        }
        else if(s!=null){
            return false;
        }
        else {
            if (s.val==t.val){
                return isSubtree(s.left,t.left)&&isSubtree(s.right,t.right);
            }
            else {
                return isSubtree(s.left,t)&&isSubtree(s.right,t);
            }
        }
    }
    public boolean isSubtree2(TreeNode s, TreeNode t) {
        if (s == null) return false;
        return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
        if (t == null && s == null) return true;
        if (t == null || s == null) return false;
        if (t.val != s.val) return false;
        return isSubtreeWithRoot(s.left, t.left) && isSubtreeWithRoot(s.right, t.right);
    }
}
```
#### Solution_617.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_617
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_617 {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1==null){
            return t2;
        }
        else if (t2==null){
            return t1;
        }
        else {
            t1.val = t1.val+t2.val;
            t1.left = mergeTrees(t1.left,t2.left);
            t1.right = mergeTrees(t1.right,t2.right);
            return t1;
        }
    }
}
```
#### Solution_637.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Solution_637 {
    public List<Double> averageOfLevels(TreeNode root) {
        List<TreeNode> list  =  new LinkedList<>();
        List<Double> result  = new ArrayList<>();
        if (root==null){
            return null;
        }
        list.add(root);
        double temp = 0;
        while (!list.isEmpty()){
            int length = list.size();
            for (int i = 0; i <length ; i++) {
                TreeNode node = list.remove(0);
                temp += node.val;
                if (node.left!=null)
                    list.add(node.left);
                if (node.right!=null)
                    list.add(node.right);
            }
            result.add(temp/length);
            temp = 0;
        }
        return result;
    }
}
```
#### Solution_671.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_671
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_671 {
    public int core(TreeNode root) {
        if (root.left==null&&root.right==null){
            return root.val;
        }

        int i = Math.min(root.left.val,root.right.val);
        if (root.val!=i){
            return i;
        }
        else if(root.val!=Math.max(root.left.val,root.right.val)){
            return Math.max(root.left.val,root.right.val);
        }
        else {
            int left = core(root.left);
            int right = core(root.right);
            int j = Math.min(left,right);
            int z = Math.max(left,right);
            if (root.val!=j){
                return j;
            }
            else if(root.val!=z){
                return z;
            }
            return -1;
         }

//        return root.val;
    }
    public int findSecondMinimumValue(TreeNode root) {
        if (root==null){
            return 0;
        }
        else if (root.left==null&&root.right==null){
            return -1;
        }
        return core(root);
    }
}
```
#### Solution_687.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_687
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_687 {
    int sum = 0;
    public int longestUnivaluePath(TreeNode root) {
        isCore(root);
        return sum;
    }
    public int isCore(TreeNode root){
        if (root==null){
            return 0;
        }
        else {
            int left = isCore(root.left);
            int right = isCore(root.right);
            System.out.println(left+"   "+right+"   "+root.val);
            if (right==root.val&&left==root.val){
                sum =  Math.max(sum,left+right+1) ;
            }
            else if (right==root.val||left==root.val){
                sum = Math.max(sum,Math.max(left,right)+1);
            }
            else {
                sum =Math.max(sum, Math.max(left,right));
            }
            return root.val;
        }
    }


    private int path = 0;
    public int longestUnivaluePath2(TreeNode root) {
        dfs(root);
        return path;
    }
    private int dfs(TreeNode root){
        if (root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int leftPath = root.left != null && root.left.val == root.val ? left + 1 : 0;
        int rightPath = root.right != null && root.right.val == root.val ? right + 1 : 0;
        path = Math.max(path, leftPath + rightPath);
        return Math.max(leftPath, rightPath);
    }
}
```
#### TreeNode.java
```java
package 数据结构相关.树;

/**
 * @ClassName TreeNode
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int x) {
        val = x;
    }
}
```
