#### BFS.java
```java
package 数据结构相关.图;

import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

/**
 * @ClassName BFS
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class BFS {
    public static void main(String[] args) {

        //构造各顶点
        LinkedList<Character> list_s = new LinkedList<Character>();
        list_s.add('w');
        list_s.add('r');
        LinkedList<Character> list_w = new LinkedList<Character>();
        list_w.add('s');
        list_w.add('i');
        list_w.add('x');
        LinkedList<Character> list_r = new LinkedList<Character>();
        list_r.add('s');
        list_r.add('v');
        LinkedList<Character> list_x = new LinkedList<Character>();
        list_x.add('w');
        list_x.add('i');
        list_x.add('u');
        list_x.add('y');
        LinkedList<Character> list_v = new LinkedList<Character>();
        list_v.add('r');
        LinkedList<Character> list_i = new LinkedList<Character>();
        list_i.add('u');
        list_i.add('x');
        list_i.add('w');
        LinkedList<Character> list_u = new LinkedList<Character>();
        list_u.add('i');
        list_u.add('x');
        list_u.add('y');
        LinkedList<Character> list_y = new LinkedList<Character>();
        list_y.add('u');
        list_y.add('x');

        //构造图
        HashMap<Character, LinkedList<Character>> graph = new HashMap<Character, LinkedList<Character>>();
        graph.put('s', list_s);
        graph.put('w', list_w);
        graph.put('r', list_r);
        graph.put('x', list_x);
        graph.put('v', list_v);
        graph.put('i', list_i);
        graph.put('y', list_y);
        graph.put('u', list_u);
        //记录每个顶点离起始点的距离，也即最短距离
        HashMap<Character, Integer> dist = new HashMap<Character, Integer>();
        //遍历的起始点
        char start = 's';
        //调用广度优先方法
        bfs(graph, dist, start);
    }

    private static void bfs(HashMap<Character, LinkedList<Character>> graph, HashMap<Character, Integer> dist,
                            char start) {
        Queue<Character> q = new LinkedList<>();
        q.add(start);// 将s作为起始顶点加入队列
        dist.put(start, 0);
        int i = 0;
        while (!q.isEmpty()) {
            char top = q.poll();// 取出队首元素
            i++;
            System.out.println("The " + i + "th element:" + top + " Distance from s is:" + dist.get(top));
            int d = dist.get(top) + 1;// 得出其周边还未被访问的节点的距离
            for (Character c : graph.get(top)) {
                if (!dist.containsKey(c))// 如果dist中还没有该元素说明还没有被访问
                {
                    dist.put(c, d);
                    q.add(c);
                }
            }
        }
    }
}
```
#### DFS.java
```java
package 数据结构相关.图;

import java.util.HashMap;
import java.util.LinkedList;

/**
 * @ClassName DFS
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class DFS {
    public static void main(String[] args) {
        //构造各顶点
        LinkedList<Character> list_u = new LinkedList<Character>();
        list_u.add('v');
        list_u.add('x');
        LinkedList<Character> list_v = new LinkedList<Character>();
        list_v.add('y');
        LinkedList<Character> list_y = new LinkedList<Character>();
        list_y.add('x');
        LinkedList<Character> list_x = new LinkedList<Character>();
        list_x.add('v');
        LinkedList<Character> list_w = new LinkedList<Character>();
        list_w.add('y');
        list_w.add('z');
        LinkedList<Character> list_z = new LinkedList<Character>();
        //构造图
        HashMap<Character, LinkedList<Character>> graph = new HashMap<Character, LinkedList<Character>>();
        graph.put('u', list_u);
        graph.put('v', list_v);
        graph.put('y', list_y);
        graph.put('x', list_x);
        graph.put('w', list_w);
        graph.put('z', list_z);

        HashMap<Character, Boolean> visited = new HashMap<Character, Boolean>();
        //调用深度优先遍历方法
        dfs(graph, visited);
    }

    private static void dfs(HashMap<Character, LinkedList<Character>> graph, HashMap<Character, Boolean> visited) {
        visit(graph, visited, 'u');// 为了和图中的顺序一样，我认为控制了DFS先访问u节点
        visit(graph, visited, 'w');
    }

    //通过一个全局变量count记录了进入每个节点和离开每个节点的时间
    static int count;
    private static void visit(HashMap<Character, LinkedList<Character>> graph, HashMap<Character, Boolean> visited,
                              char start) {
        if (!visited.containsKey(start)) {
            count++;
            System.out.println("The time into element " + start + ":" + count);// 记录进入该节点的时间
            visited.put(start, true);
            for (char c : graph.get(start)) {
                if (!visited.containsKey(c)) {
                    visit(graph, visited, c);// 递归访问其邻近节点
                }
            }
            count++;
            System.out.println("The time out element " + start + ":" + count);// 记录离开该节点的时间
        }
    }

}
```
#### minPathLength.java
```java
package 数据结构相关.图;
import java.util.LinkedList;
/**
 * @ClassName minPathLength
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class minPathLength {
    public int minPathLength(int [][]grids,int tr,int tc){
        int [][] direction = {{1,0},{-1,0},{0,1},{0,-1}};
        int m = grids.length;
        int n = grids[0].length;
        LinkedList<Pair<Integer,Integer>> queue = new LinkedList<>();
        int pathlength = 0;
        queue.add(new Pair<>(0,0));
        while (!queue.isEmpty()){
            int size = queue.size();
            pathlength++;
            while (size-->0){
                Pair<Integer,Integer> cur = queue.poll();
                int cr = cur.getKey();
                int cc = cur.getValue();
                grids[cr][cc] = 0;
                for (int []d:direction) {
                    int nr = cr +d[0];
                    int nc = cc +d[1];
                    if (nr<0||nr>=m||nc<0||nc>=n||grids[nr][nc]==0){
                        continue;
                    }
                    if (nr == tr && nc ==tc){
                        return pathlength;
                    }
                    queue.add(new Pair<>(nr,nc));
                }
            }
        }
        return -1;
    }
}
class Pair<K,V>{
    K key;
    V value;
    public Pair(K key,V value) {
        this.key=key;
        this.value=value;
    }
    public K getKey() {
        return this.key;
    }
    public V getValue() {
        return  this.value;
    }
}
```
#### Solution_785.java
```java
package 数据结构相关.图;

/**
 * @ClassName Solution_785
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_785 {
    public boolean isBipartite(int[][] graph) {
        //测试通过 75/78
        int[] visit = new int[graph.length];
        for (int i = 0; i < graph.length; i++) {
            for (int j = 0; j < graph[i].length; j++) {
                if (visit[i]==0){
                    visit[i]=1;
                    if (visit[graph[i][j]]==2||visit[graph[i][j]]==0){
                        visit[graph[i][j]]=2;
                    }
                    else {
                        return false;
                    }
                }
                else if (visit[i]==1){
                    if (visit[graph[i][j]]==2||visit[graph[i][j]]==0){
                        visit[graph[i][j]]=2;
                    }
                    else {
                        return false;
                    }
                }
                else if (visit[i]==2){
                    if (visit[graph[i][j]]==1||visit[graph[i][j]]==0){
                        visit[graph[i][j]]=1;
                    }
                    else {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```
