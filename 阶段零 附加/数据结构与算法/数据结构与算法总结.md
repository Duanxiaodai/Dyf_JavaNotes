## LeetCode算法分类

![1567125031837](./imgs/1567125031837.png)



## 互联网公司面试中经常考察的问题类型总结的思维导图 



![leetcode-zhihu](https://github.com/azl397985856/leetcode/raw/master/assets/leetcode-zhihu.jpg)

 

## 总结：

#### 其中基础算法，主要是以下几种：

- 基础技巧：分治、二分、贪心
- 排序算法：快速排序、归并排序、计数排序
- 搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
- 图论：最短路径、最小生成树
- 动态规划：背包问题、最长子序列

#### 基本数据结构，主要有如下几种：

- 数组与链表：单 / 双向链表
- 数组与矩阵
- 栈与队列
- 哈希表
- 堆：最大堆 ／ 最小堆
- 树与图：最近公共祖先、并查集（主要用途）
- 字符串：前缀树（字典树） ／ 后缀树

#### 解题常用算法思想

- 双指针
- 排序
- 贪心思想
- 二分查找
- 分治
- 搜索
- 动态规划
- 数学
- 位运算



```java
package 搜索.回溯;

import java.util.ArrayList;
import java.util.List;

/**
 * @ClassName Solution_46
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_46 {

    //单纯用递归 效率很差
    public List<List<Integer>> permute(int[] nums) {
        if (nums.length==0){
            return new ArrayList<>();
        }
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            list.add(nums[i]);
        }
        return core(list);
    }
    public List<List<Integer>> core(List<Integer> nums){
        if (nums.size()==1){
            ArrayList<Integer> integers = new ArrayList<>();
            integers.add(nums.get(0));
            List<List<Integer>> lists = new ArrayList<>();
            lists.add(integers);
            return lists;
        }
        else {
            List<List<Integer>> lists = new ArrayList<>();
            for (int i = 0; i <nums.size() ; i++) {
                Integer remove = nums.remove(i);
                List<List<Integer>> temp =  core(nums);
                nums.add(i,remove);
                for (List<Integer> list: temp) {
                    list.add(0,nums.get(i));
                    lists.add(list);
                }
            }
            return lists;
        }
    }

    //回溯改进
    //效率改进很大
    //细节点，在递归结束时是否应该重新创建，，，因为后续操作有可能影响temp的内容
    public List<List<Integer>> permute2(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> temp = new ArrayList<>();
        boolean []meno = new boolean[nums.length];
        backtrack(res,temp,meno,nums);
        return res;
    }
    private void backtrack(List<List<Integer>> res, List<Integer> temp, boolean[] meno, int[] nums) {
        if (temp.size() == nums.length){
            res.add(new ArrayList<>(temp));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (meno[i]){
                continue;
            }
            meno[i]=true;
            temp.add(nums[i]);
            backtrack(res,temp,meno,nums);
            meno[i]=false;
            temp.remove(temp.size()-1);
        }
    }
}
```

