# LeetCode算法分类

![1567125031837](./imgs/1567125031837.png)



# 互联网公司面试中经常考察的问题类型总结的思维导图 



![leetcode-zhihu](https://github.com/azl397985856/leetcode/raw/master/assets/leetcode-zhihu.jpg)

 

# 总结：

### 其中基础算法，主要是以下几种：

- 基础技巧：分治、二分、贪心
- 排序算法：快速排序、归并排序、计数排序
- 搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
- 图论：DFS、BFS、拓扑排序、<u>最短路径、最小生成树、关键路径</u>
- 动态规划：背包问题、最长子序列

### 基本数据结构，主要有如下几种：

- 数组与链表：单 / 双向链表
- [数组与矩阵](./Leetcode/数组与矩阵.md)
- [栈与队列](./Leetcode/堆栈.md)
- 哈希表
- 堆：最大堆 ／ 最小堆（用来求最值问题）
- 树与图：二叉树、二叉搜索树、哈夫曼树、==最近公共祖先==、并查集（主要用途）
- 字符串：前缀树（字典树） ／ 后缀树

### 特定的数据结构解决特定的问题

并查集：最近公共祖先、图的连通性

[前缀树](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/ )：特定的哈希树、大量字符串的前缀匹配、大量字符串排序

[哈希树](https://www.cnblogs.com/tlnshuju/p/6740754.html)：

### 解题常用算法思想

- 双指针
- 滑动窗口（高级双指针）
- 排序
- 贪心思想
- 二分查找
- 分治
- 搜索
- [动态规划](./Leetcode/动态规划.md)
- 数学
- 位运算
- ==布隆过滤器（?）==



### 针对特定问题的思路总结：

#### 回溯算法

​        回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优[搜索](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2/2791632)法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 

​        回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。[八皇后问题](https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的[节点](https://baike.baidu.com/item/%E8%8A%82%E7%82%B9)，从而减少状态空间树节点的生成。[回溯法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95)是一个既带有系统性又带有跳跃性的的[搜索算法](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而[回溯法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95)在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。 



#### 树：树的问题就是遍历的问题

基础：先，中，后，层次  除特殊要求外，用递归可以简化操作和化简问题

#### 二叉树的遍历

- 递归
- 借助栈的迭代方法
- 莫里斯遍历（按序线索化二叉树，优化空间）

- “颜色标记法”

  兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。

其核心思想如下：

使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。
如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。
如果遇到的节点为灰色，则将节点的值输出。

##### 



#### 二叉树搜索树在中序遍历的过程中记录上一节点：很有用

```java
    //递归
    Integer pro ;// 保存前一个节点
    public boolean isValidBST2(TreeNode root) {
        if(root == null){
            return true;
        }
        if (!isValidBST(root.left)){
            return false;
        }
        if (pro!=null&&pro>=root.val){
            return false;
        }
        pro = root.val;  // 更新前一个节点
        return isValidBST(root.right);
    }
    //迭代
    public boolean isValidBST3(TreeNode root) {
        Stack<TreeNode> stack = new Stack();
        double inorder = - Double.MAX_VALUE;//保存 前一个节点
        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            // If next element in inorder traversal
            // is smaller than the previous one
            // that's not BST.
            if (root.val <= inorder) 
                return false;
            inorder = root.val;  //更新前一个节点
            root = root.right;
        }
        return true;
    }
```

#### 二叉树的莫里斯遍历

目的优化空间复杂度

二叉树常规的遍历方法是用递归来实现的，这种方法一般都需要O(n)的空间复杂度和O(n)的时间复杂度。而Morris方法实现的是O(1)的空间复杂度和O(n)的时间复杂度。
我们知道，遍历二叉树时，最大的难点在于，**遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针）**，由于不能用栈作为辅助空间。为了解决这个问题，Morris方法用到了[线索二叉树](http://en.wikipedia.org/wiki/Threaded_binary_tree#The_array_of_Inorder_traversal)（threaded binary tree）的概念。在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），**只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了**。

#### 前缀树

前缀树又名字典树，单词查找树，Trie树，是一种多路树形结构，是哈希树的变种，和hash效率有一拼，是一种用于快速检索的多叉树结构。<https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/> 

典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

Trie树也有它的缺点，Trie树的内存消耗非常大。

性质：不同字符串的相同前缀只保存一份。

操作：查找，插入，删除。

#### 动态规划（可以从左到右，也可从右到左）

一个动态规划问题，通常解决并理解一个动态规划问题需要以下 4 个步骤：

​	利用递归回溯解决问题
	利用记忆表优化（自顶向下的动态规划）
	移除递归的部分（自底向上的动态规划）
	使用技巧减少时间和空间复杂度

方法 1：回溯
	这是一个低效的解决方法。我们模拟从第一个位置跳到最后位置的所有方案。从第一个位置开始，模拟所有可以跳到的位置，然后从当前位置重复上述操作，当没有办法继续跳的时候，就回溯。

方法 2：自顶向下的动态规划
	自顶向下的动态规划可以理解成回溯法的一种优化。我们发现当一个坐标已经被确定为好 / 坏之后，结果就不会改变了，这意味着我们可以记录这个结果，每次不用重新计算。	

方法 3：自底向上的动态规划
	底向上和自顶向下动态规划的区别就是消除了回溯，在实际使用中，自底向下的方法有更好的时间效率因为我们不再需要栈空间，可以节省很多缓存开销。更重要的事，这可以让之后更有优化的空间。回溯通常是通过反转动态规划的步骤来实现的。

#### 多数投票问题

​	利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N) 

 	Boyer-Moore Majority Vote Algorithm的更一般性问题 

1) 问题描述
基本问题：对于一个给定数组A[0:n-1],找出出现次数大于⌊n/2⌋⌊n/2⌋ 的元素，称为Majority element. 
一般问题：对于一个给定数组A[0:n-1],找出出现次数大于⌊n/k⌋(k≥2)⌊n/k⌋(k≥2)的所有元素.

LeetCode问题链接： 
Majority Element： https://leetcode.com/problems/majority-element/ 
Majority Element II: https://leetcode.com/problems/majority-element-ii/ 
————————————————
版权声明：本文为CSDN博主「isunn」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/isunn/article/details/50735232



#### 堆的特殊使用场景

- 复杂度：O(NlogK) + O(K)
- 特别适合处理海量数据（维护需求容量的堆大小，进行替换操作）




### 需要再次回顾与优化的题目：

#### LeetCode	

| 题号 |              名              |
| :--: | :--------------------------: |
| 148  |       链表的快排与归并       |
|      |             LRU              |
| 889  | 根据前序和后序遍历构造二叉树 |
|  4   |      两个有序数组的TopK      |



#### Offer

​	











#### 记录刷题

| 日期  | 题号                  |
| ----- | --------------------- |
| 10.23 | 152 98                |
| 10.24 | 560（优化） 621(未做) |
|       | 169 229               |
|       |                       |

