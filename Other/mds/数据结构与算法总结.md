# LeetCode算法分类

![1567125031837](./imgs/1567125031837.png)



# 互联网公司面试中经常考察的问题类型总结的思维导图 



![leetcode-zhihu](https://github.com/azl397985856/leetcode/raw/master/assets/leetcode-zhihu.jpg)

 

# 总结：

### 其中基础算法，主要是以下几种：

- 基础技巧：分治、二分、贪心
- 排序算法：快速排序、归并排序、计数排序
- 搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等
- 图论：DFS、BFS、拓扑排序、<u>最短路径、最小生成树、关键路径</u>
- 动态规划：背包问题、最长子序列

### 基本数据结构，主要有如下几种：

- 数组与链表：单 / 双向链表
- 数组与矩阵
- 栈与队列
- 哈希表
- 堆：最大堆 ／ 最小堆
- 树与图：二叉树、二叉搜索树、哈夫曼树、==最近公共祖先==、并查集（主要用途）
- 字符串：前缀树（字典树） ／ 后缀树

### 特定的数据结构解决特定的问题

并查集：最近公共祖先、图的连通性

[前缀树](https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/ )：特定的哈希树、大量字符串的前缀匹配、大量字符串排序

[哈希树](https://www.cnblogs.com/tlnshuju/p/6740754.html)：

### 解题常用算法思想

- 双指针
- 排序
- 贪心思想
- 二分查找
- 分治
- 搜索
- 动态规划
- 数学
- 位运算
- ==布隆过滤器（?）==



### 针对特定问题的思路总结：

#### 回溯算法

​        回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优[搜索](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2/2791632)法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 

​        回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。[八皇后问题](https://baike.baidu.com/item/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98)就是回溯算法的典型，第一步按照顺序放一个皇后，然后第二步符合要求放第2个皇后，如果没有位置符合要求，那么就要改变第一个皇后的位置，重新放第2个皇后的位置，直到找到符合条件的位置就可以了。回溯在迷宫搜索中使用很常见，就是这条路走不通，然后返回前一个路口，继续下一条路。回溯算法说白了就是穷举法。不过回溯算法使用剪枝函数，剪去一些不可能到达 最终状态（即答案状态）的[节点](https://baike.baidu.com/item/%E8%8A%82%E7%82%B9)，从而减少状态空间树节点的生成。[回溯法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95)是一个既带有系统性又带有跳跃性的的[搜索算法](https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95)。它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先的策略进行搜索。回溯法在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而[回溯法](https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95)在用来求问题的任一解时，只要搜索到问题的一个解就可以结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。 



#### 树：树的问题就是遍历的问题

基础：先，中，后，层次  除特殊要求外，用递归可以简化操作和化简问题

#### 二叉树的遍历

- 递归
- 借助栈的迭代方法
- 莫里斯遍历（按序线索化二叉树，优化空间）

- “颜色标记法”

  兼具栈迭代方法的高效，又像递归方法一样简洁易懂，更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。

其核心思想如下：

使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。
如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。
如果遇到的节点为灰色，则将节点的值输出。

#### 二叉树的莫里斯遍历

目的优化空间复杂度

二叉树常规的遍历方法是用递归来实现的，这种方法一般都需要O(n)的空间复杂度和O(n)的时间复杂度。而Morris方法实现的是O(1)的空间复杂度和O(n)的时间复杂度。
我们知道，遍历二叉树时，最大的难点在于，**遍历到子节点的时候怎样重新返回到父节点（假设节点中没有指向父节点的p指针）**，由于不能用栈作为辅助空间。为了解决这个问题，Morris方法用到了[线索二叉树](http://en.wikipedia.org/wiki/Threaded_binary_tree#The_array_of_Inorder_traversal)（threaded binary tree）的概念。在Morris方法中不需要为每个节点额外分配指针指向其前驱（predecessor）和后继节点（successor），**只需要利用叶子节点中的左右空指针指向某种顺序遍历下的前驱节点或后继节点就可以了**。

#### 前缀树

前缀树又名字典树，单词查找树，Trie树，是一种多路树形结构，是哈希树的变种，和hash效率有一拼，是一种用于快速检索的多叉树结构。<https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode/> 

典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较，查询效率比哈希表高。

Trie的核心思想是空间换时间。利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。

Trie树也有它的缺点，Trie树的内存消耗非常大。

性质：不同字符串的相同前缀只保存一份。

操作：查找，插入，删除。
