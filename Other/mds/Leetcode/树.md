#### Solution_101.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_101
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_101 {
    public boolean isSymmetric(TreeNode root) {
        if (root==null){
            return true;
        }
        else {
            return isCore(root.left,root.right);
        }
    }
    public boolean isCore(TreeNode left,TreeNode right) {
        if (left==null&&right==null){
            return true;
        }
        else if (left==null||right==null){
            return false;
        }
        else {
            if (left.val!=right.val){
                return false;
            }
            return isCore(left.left,right.right)&&isCore(left.right,right.left);
        }
    }


}
```
#### Solution_105.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_105
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_105 {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        if (preorder.length==0){
            return null;
        }
        return core(preorder,inorder,0,preorder.length-1,0,inorder.length-1);
    }
    private TreeNode core(int[] preorder, int[] inorder, int begin, int end, int left, int right) {
        if (begin == end){
            return new TreeNode(preorder[begin]);
        }
        if (begin>end){
            return null;
        }
        TreeNode root = new TreeNode(preorder[begin]);
        int index = index(inorder,left,right, preorder[begin]);
        root.left = core(preorder,inorder,begin+1,begin+index-left,left,index-1);
        root.right = core(preorder,inorder,begin+index-left+1,end,index+1,end);
        return root;
    }
    int index(int [] temp ,int left , int right ,int x){
        for (int i = left; i <= right; i++) {
            if (temp[i]==x){
                return i;
            }
        }
        return -1;
    }



    public TreeNode buildTree2(int[] preorder, int[] inorder) {
        return buildTreeHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
    }

    private TreeNode buildTreeHelper(int[] preorder, int p_start, int p_end, int[] inorder, int i_start, int i_end) {
        // preorder 为空，直接返回 null
        if (p_start == p_end) {
            return null;
        }
        int root_val = preorder[p_start];
        TreeNode root = new TreeNode(root_val);
        //在中序遍历中找到根节点的位置
        int i_root_index = 0;
        for (int i = i_start; i < i_end; i++) {
            if (root_val == inorder[i]) {
                i_root_index = i;
                break;
            }
        }
        int leftNum = i_root_index - i_start;
        //递归的构造左子树
        root.left = buildTreeHelper(preorder, p_start + 1, p_start + leftNum + 1, inorder, i_start, i_root_index);
        //递归的构造右子树
        root.right = buildTreeHelper(preorder, p_start + leftNum + 1, p_end, inorder, i_root_index + 1, i_end);
        return root;
    }


}
```
#### Solution_106.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_106
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_106 {

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if (postorder.length==0){
            return null;
        }
        return core(postorder,inorder,0,postorder.length-1,0,inorder.length-1);
    }
    private TreeNode core(int[] postorder, int[] inorder, int begin, int end, int left, int right) {
        if (begin>end||begin<0){
            return null;
        }
        if (begin == end){
            return new TreeNode(postorder[begin]);
        }
        TreeNode root = new TreeNode(postorder[end]);
        int index = index(inorder,left,right, postorder[end]);
        root.left = core(postorder,inorder,begin,begin+index-left-1,left,index-1);
        root.right = core(postorder,inorder,begin+index-left,end-1,index+1,right);
        return root;
    }
    int index(int [] temp ,int left , int right ,int x){
        for (int i = left; i <= right; i++) {
            if (temp[i]==x){
                return i;
            }
        }
        return -1;
    }
}
```
#### Solution_107.java
```java
package 数据结构相关.树;

import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_107
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_107 {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> lists = new LinkedList<>();
        if (root==null){
            return lists;
        }
        LinkedList <TreeNode> list = new LinkedList<>();
        list.add(root);
        while (!list.isEmpty()){
            int size = list.size();
            LinkedList <Integer> temp = new LinkedList<>();
            while (size>=0){
                TreeNode remove = list.remove(0);
                if (remove.left!=null){
                    list.add(remove.left);
                }
                if (remove.right!=null){
                    list.add(remove.right);
                }
                temp.add(remove.val);
                size--;
            }
            lists.add(0,temp);
        }
        return lists;
    }
}
```
#### Solution_108.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_108
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_108 {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums.length==0){
            return null;
        }
        return iscore(nums,0,nums.length-1);
    }
    public TreeNode iscore(int [] nums,int begin,int end){
        if (begin==end){
            return new TreeNode(nums[begin]);
        }
        else{
            TreeNode root = new TreeNode(nums[(begin+end)/2]);
            if ((begin+end)/2-1>=begin){
                root.left = iscore(nums,begin,(begin+end)/2-1);
            }
            if((begin+end)/2+1<=end){
                root.right = iscore(nums,(begin+end)/2+1,end);
            }
            return root;
        }
    }
}
```
#### Solution_109.java
```java
package 数据结构相关.树;

import 数据结构相关.链表.ListNode;

/**
 * @ClassName Solution_109
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_109 {

    public TreeNode sortedListToBST(ListNode head) {
        if(head == null){
            return null;
        }
        if(head.next == null){
            return new TreeNode(head.val);
        }
        ListNode first = head;
        ListNode second = head;
        ListNode pro = first;
        while (second != null&&second.next!=null){
            pro = first;
            first = first.next;
            second = second.next.next;
        }
        second = first.next;
        pro.next = null;
        TreeNode root = new TreeNode(first.val);
        root.left = sortedListToBST(head);
        root.right = sortedListToBST(second);
        return root;
    }
}
```
#### Solution_110.java
```java
package 数据结构相关.树;

public class Solution_110 {
    public boolean isBalanced(TreeNode root) {
        if (root==null){
            return true;
        }
        else {
            if (isBalanced(root.right)&&isBalanced(root.left)&&Math.abs(deep(root.right)-deep(root.left))<=1){
                return true;
            }
            return false;
        }
    }
    public int deep(TreeNode root){
        if (root==null){
            return 0;
        }
        else{
            return 1+Math.max(deep(root.right),deep(root.left));
        }
    }




    ///////////第二种
    private boolean result = true;

    public boolean isBalanced2(TreeNode root) {
        maxDepth(root);
        return result;
    }

    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int l = maxDepth(root.left);
        int r = maxDepth(root.right);
        if (Math.abs(l - r) > 1) result = false;
        return 1 + Math.max(l, r);
    }
}
```
#### Solution_111.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_111
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_111 {
    public int minDepth(TreeNode root) {
        if (root == null ){
            return 0;
        }
        if(root.left==null&&root.right==null){
            return 1;
        }
        if (root.left==null&&root.right!=null){
            return 1+minDepth(root.right);
        }
        else if (root.left!=null&&root.right==null){
            return 1+minDepth(root.left);
        }
        else {
            return 1+Math.min(minDepth(root.right),minDepth(root.left));
        }
    }
}
```
#### Solution_112.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_112
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_112 {
    public boolean hasPathSum(TreeNode root, int sum) {
        if (root==null){
            return false;
        }
        else if (root.left==null&&root.right==null){
            if (sum == root.val){
                return true;
            }
            return false;
        }
        else {
            return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
        }
    }
}
```
#### Solution_144.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_144
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_144 {
    //递归二叉树的遍历
    public List<Integer> preorderTraversal(TreeNode root) {
        if (root==null){
            return new ArrayList<>();
        }
        List<Integer> res = new ArrayList<>();
        res.add(root.val);
        res.addAll(preorderTraversal(root.left));
        res.addAll(preorderTraversal(root.right));
        return res;
    }
    //非递归
    public List<Integer> preorderTraversal2(TreeNode root) {
        if (root==null){
            return new ArrayList<>();
        }
        List<Integer> res = new ArrayList<>();
        LinkedList<TreeNode> stack  = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode pop = stack.pop();
            res.add(pop.val);
            if (pop.right!=null)
                stack.push(pop.right);
            if (pop.left!=null)
                stack.push(pop.left);
        }
        return res;
    }
}
```
#### Solution_145.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_145
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_145 {
    //递归  二叉树的后序遍历
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        helper(root,res);
        return res;
    }
    private void helper(TreeNode root,List<Integer> res) {
        if (root==null){
            return;
        }
        helper(root.left,res);
        helper(root.right,res);
        res.add(root.val);
    }
    //迭代
    public List<Integer> postorderTraversal2(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root==null){
            return res;
        }
        LinkedList<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()){
            TreeNode first = stack.pop();
            res.add(first.val);
            if (first.left!=null){
                stack.push(first.left);
            }
            if (first.right!=null){
                stack.push(first.right);
            }
        }
        Collections.reverse(res);
        return res;
    }
    public List<Integer> postorderTraversal3(TreeNode root) {
        LinkedList<TreeNode> stack = new LinkedList<>();
        LinkedList<Integer> output = new LinkedList<>();
        if (root == null) {
            return output;
        }

        stack.add(root);
        while (!stack.isEmpty()) {
            TreeNode node = stack.pollLast();
            output.addFirst(node.val);
            if (node.left != null) {
                stack.add(node.left);
            }
            if (node.right != null) {
                stack.add(node.right);
            }
        }
        return output;
    }
}
```
#### Solution_208.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_20
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_208{

}
class Trie {
    /** Initialize your data structure here. */
    Trie []array ;
    boolean end ;
    public Trie() {
        array =new Trie [26];
        end = false;
    }
    /** Inserts a word into the trie. */
    public void insert(String word) {
        if (word.length()==1){
            if (array[word.charAt(0)-'a']==null){
                array[word.charAt(0)-'a'] =  new Trie();
            }
            array[word.charAt(0)-'a'].end = true;
        }
        else {
            if (array[word.charAt(0)-'a']==null){
                array[word.charAt(0)-'a'] = new Trie();
            }
            array[word.charAt(0)-'a'].insert(word.substring(1));
        }
    }
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        if (word.length()==1){
            if (array[word.charAt(0)-'a']!=null&&array[word.charAt(0)-'a'].end)
                return true;
            else
                return false;
        }
        else {
            if (array[word.charAt(0)-'a']!=null){
                return array[word.charAt(0)-'a'].search(word.substring(1));
            }
            return false;
        }
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
        if (prefix.length()==1){
            if (array[prefix.charAt(0)-'a']!=null)
                return true;
            else
                return false;
        }
        else {
            if (array[prefix.charAt(0)-'a']!=null){
                return  array[prefix.charAt(0)-'a'].startsWith(prefix.substring(1));
            }
            return false;
        }
    }
}
```
#### Solution_230.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_230
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_230 {
    int res ;
    int kk;
    public int kthSmallest(TreeNode root, int k) {
        kk = k;
        core(root,kk);
        return res;
    }
    private void core(TreeNode root, int k) {
        if (root==null){
            return ;
        }
        kthSmallest(root.left,kk);
        kk--;
        if (kk<0){//剪枝
            return;
        }
        if (kk==0){
            res = root.val;
            return;
        }
        kthSmallest(root.right,kk);
    }
}
```
#### Solution_235.java
```java
package 数据结构相关.树;

import java.util.LinkedList;

/**
 * @ClassName Solution_235
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_235 {
    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {
        if (root==null){
            return null;
        }
        if (root.val<p.val&&root.val<q.val){
            return lowestCommonAncestor1(root.right,p,q);
        }
        else if (root.val<=p.val&&root.val<=q.val){
            return root;
        }
        else if (root.val>p.val&&root.val>q.val){
            return lowestCommonAncestor1(root.left,p,q);
        }
        else if (root.val>=p.val&&root.val>=q.val){
            return root;
        }
        else if ((root.val<p.val&&root.val>q.val)||(root.val>p.val&&root.val<q.val)){
            return root;
        }
        return root;
    }




    int sum = 0;
    boolean flag =false;
    TreeNode res;
    //DFS 没过
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        core(root,p,q );
        return res;
    }
    private void core(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null){
            return;
        }
        if (flag){//剪枝
            return;
        }
        core(root.left,p,q);
        core(root.right,p,q);
        if (sum==2){
            flag = true;//结果搜索到 进行标记
            res = root;
            return;
        }
        if (root==p||root==q){
            sum++;
        }
        if (sum==2){
            flag = true;//结果搜索到 进行标记
            res = root;
        }
    }
    //暴力解
    public TreeNode lowestCommonAncestor2(TreeNode root, TreeNode p, TreeNode q) {
        if (root==null){
            return null;
        }
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (!queue.isEmpty()){
            int size = queue.size();
            while (size-->0){
                TreeNode Node = queue.removeFirst();
                if (Node.left!=null)
                    queue.add(Node.left);
                if (Node.right!=null)
                    queue.add(Node.right);
                if (have(Node,q)&&have(Node,p)){
                    res = Node;
                }
            }
        }
        return res;
    }
    private boolean have(TreeNode root,TreeNode temp){
        if (root==null){
            return false;
        }
        if (root==temp){
            return true;
        }
        return have(root.left,temp)||have(root.right,temp);
    }
}
```
#### Solution_236.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_236
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_236 {


    public TreeNode lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q) {
        if (root==null||root==p||root==q){
            return root;
        }
        TreeNode treeNode1 = lowestCommonAncestor1(root.left, p, q);
        TreeNode treeNode2 = lowestCommonAncestor1(root.right, p, q);
        if (treeNode1!=null&&treeNode2!=null){
            return root;
        }
        if (root == p||root == q){
            return root;
        }
        if (treeNode1==null){
            return treeNode2;
        }
        else {
            return treeNode1;
        }
    }




    //没有过
    int count = 0;
    TreeNode res;
    boolean flag = false;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        core(root,p,q);
        return res;
    }
    private void core(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null){
            return;
        }
        core(root.left,p,q);
        core(root.right,p,q);
        if (flag){
            return;
        }
        if (count==2){
            flag = true;
            res = root;
            return;
        }
        if (root==p||root==q){
            count++;
        }
    }
}
```
#### Solution_337.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_337
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_337 {
//    int i = 0;
    LinkedList<Integer> list = new LinkedList();
    public int rob(TreeNode root) {
        if (root==null){
            return 0;
        }
        else {
            int core = core(root);
        }
        return core(root);
    }
    public int core(TreeNode root) {
        if (root == null){
            return 0;
        }
        else {
            int left = core(root.left);
            int right = core(root.right);
            int k = list.isEmpty()? 0 : list.peek();
            int max = Math.max(root.val + k, left + right);
            list.add(left+right);
            return max;
        }
    }

}
```
#### Solution_404.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_404
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_404 {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root==null){
            return 0;
        }
        else {
            return sumOfLeftLeaves(root.left,0)+sumOfLeftLeaves(root.right,1);
        }
    }
    public int sumOfLeftLeaves(TreeNode root,int i) {
        if (root==null){
            return 0;
        }
        else if (root.left==null&&root.right==null){
            if (i==0){
                return root.val;
            }
            else {
                return 0;
            }
        }
        else {
            return sumOfLeftLeaves(root.left,0)+sumOfLeftLeaves(root.right,1);
        }
    }


}
```
#### Solution_437.java
```java
package 数据结构相关.树;

import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_437
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_437 {
    static  int result =0;
    public int pathSum(TreeNode root, int sum) {
        if (root==null){
            return 0;
        }
        else if (root.val == sum){
            sum++;
        }
        else if (root.val>sum){
            return 0;
        }
        pathSum(root.left,sum - root.val);
        pathSum(root.right,sum - root.val);
        pathSum(root.left,sum );
        pathSum(root.right,sum );
        return sum;
    }
}
class Solution {
    int path  = 0;
    public int pathSum(TreeNode root, int sum) {
        List<TreeNode> list =new LinkedList<>();
        list.add(root);
        while (!list.isEmpty()){
            TreeNode temp = ((LinkedList<TreeNode>) list).remove(0);
            pathSumCore(temp,sum,0);
            if (temp!=null){
                list.add(temp.left);
                list.add(temp.right);
            }
        }
        return path;
    }

    public void pathSumCore(TreeNode root ,int sum,int now){

        if (root==null){
            return ;
        }
        if (sum==(now=now+root.val)){
            now=0;
            path++;
        }

        //now = root.val+now;
        pathSumCore(root.left,sum,now);
        pathSumCore(root.right,sum,now);

    }
}
```
#### Solution_501.java
```java
package 数据结构相关.树;

import java.util.ArrayList;

/**
 * @ClassName Solution_501
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_501 {
    ArrayList<Integer> res = new ArrayList<>();
    TreeNode pro = null;
    int num = 1;
    int bignum = 0;
    public int[] findMode(TreeNode root) {
        core(root);
//        if (num>=bignum){
//            if (num>bignum)
//                res.clear();
//            while (root.right!=null){
//                root = root.right;
//            }
//            res.add(root.val);
//        }
        int [] result = new int[res.size()];
        for (int i = 0; i < res.size(); i++) {
            result[i] = res.get(i);
        }
        return result;
    }
    private void core(TreeNode root) {
        if (root==null){
            return;
        }
        core(root.left);
        if (pro != null){
            if (pro.val==root.val){
                num++;
            }
            else {
                num = 1;
            }
        }
        if (bignum==num){
            res.add(pro.val);
        }
        else if (bignum<num){
            res.clear();
            res.add(pro.val);
            bignum = num;
        }
        pro = root;
        core(root.right);
    }
}
```
#### Solution_513.java
```java
package 数据结构相关.树;

import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_513
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_513 {
    //bfs
    public int findBottomLeftValue(TreeNode root) {
        return core(root);
    }
    private int core(TreeNode root) {
        List<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        int res = 0;
        while (!queue.isEmpty()){
            int size = queue.size();
            res = ((LinkedList<TreeNode>) queue).getFirst().val;
            while (size-->0){
                TreeNode treeNode = ((LinkedList<TreeNode>) queue).removeFirst();
                if (treeNode.left!=null){
                    queue.add(treeNode.left);
                }
                if (treeNode.right!=null){
                    queue.add(treeNode.right);
                }
            }
        }
        return res;
    }

    //dfs
    int maxDepth = -1, res = -1;
    public int findBottomLeftValue2(TreeNode root) {
        helper(root, 0);
        return res;
    }
    private void helper(TreeNode root, int depth) {
        if (root == null) return;
        helper(root.left, depth + 1);
        //判断是否是最大深度
        if (depth > maxDepth) {
            maxDepth = depth;
            res = root.val;
        }
        helper(root.right, depth + 1);
    }
}
```
#### Solution_530.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.LinkedList;

/**
 * @ClassName Solution_530
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_530 {
    public int getMinimumDifference(TreeNode root) {
        ArrayList<Integer> res =new ArrayList<>();
        core(root,res);
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < res.size()-2; i++) {
            if (min>Math.abs(res.get(i)-res.get(i+1))){
                min  = Math.abs(res.get(i)-res.get(i+1));
            }
        }
        return min;
    }
    //中序递归遍历+ 数组
    private void core(TreeNode root, ArrayList<Integer> res) {
        if (root == null){
            return;
        }
        core(root.left,res);
        res.add(root.val);
        core(root.right,res);
    }
    //中序非递归
    public int getMinimumDifference2(TreeNode root) {
        core2(root);
        return min;
    }
    int min;
    private void core2(TreeNode root){
        LinkedList<TreeNode> stack = new LinkedList<>();
        TreeNode cur = root;
        stack.push(cur);
        min = Integer.MAX_VALUE;
        TreeNode pro = null;
        while (!stack.isEmpty()){
            while (cur.left!=null){
                cur = cur.left;
                stack.push(cur);
            }
            TreeNode pop  = stack.pop();
            if (pro!=null){
                min = Math.min(min,Math.abs(pro.val-pop.val));
//                System.out.println(pro.val+"  "+pop.val);
            }
            pro = pop;
            if (pop.right!=null){
                cur =pop.right;
                stack.push(cur);
            }
        }
    }

    //中序递归  用类变量来存储 前一个访问的节点
    int res  = Integer.MAX_VALUE;
    TreeNode pro = null;
    private void core(TreeNode root) {
        if (root == null){
            return ;
        }
        core(root.left);
        if (pro!=null){
            res = Math.min(res,Math.abs(pro.val-root.val));
        }
        pro = root;
        core(root.right);
    }
}
```
#### Solution_538.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_53
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_538 {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if (root==null){
            return null;
        }
        core(root);
        return root;
    }
    private void core(TreeNode root) {
        if (root==null){
            return;
        }
        core(root.right);
        sum = sum+root.val;
        root.val = sum;
        core(root.left);
    }
}
```
#### Solution_543.java
```java
package 数据结构相关.树;

import java.util.Collections;
import java.util.Vector;
import java.util.concurrent.atomic.AtomicInteger;

public class Solution_543 {
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null)
            return 0;
        else {
            int temp =  deep(root.right)+deep(root.left);
            int i = diameterOfBinaryTree(root.right);
            int j = diameterOfBinaryTree(root.left);
            if (temp>i){
                return temp;
            }
            else if (i>j){
                return i;
            }
            else {
                return j;
            }
        }
    }
    public int deep(TreeNode root){
        if (root==null){
            return 0;
        }
        else{
            return 1+Math.max(deep(root.right),deep(root.left));
        }
    }










    private int max = 0;

    public int diameterOfBinaryTree2(TreeNode root) {
        depth(root);

        return max;

    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = depth(root.left);
        int rightDepth = depth(root.right);
        max = Math.max(max, leftDepth + rightDepth);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```
#### Solution_572.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_572
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/

public class Solution_572 {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (t==null){
            return true;
        }
        else if(s!=null){
            return false;
        }
        else {
            if (s.val==t.val){
                return isSubtree(s.left,t.left)&&isSubtree(s.right,t.right);
            }
            else {
                return isSubtree(s.left,t)&&isSubtree(s.right,t);
            }
        }
    }
    public boolean isSubtree2(TreeNode s, TreeNode t) {
        if (s == null) return false;
        return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
        if (t == null && s == null) return true;
        if (t == null || s == null) return false;
        if (t.val != s.val) return false;
        return isSubtreeWithRoot(s.left, t.left) && isSubtreeWithRoot(s.right, t.right);
    }
}
```
#### Solution_617.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_617
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_617 {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1==null){
            return t2;
        }
        else if (t2==null){
            return t1;
        }
        else {
            t1.val = t1.val+t2.val;
            t1.left = mergeTrees(t1.left,t2.left);
            t1.right = mergeTrees(t1.right,t2.right);
            return t1;
        }
    }
}
```
#### Solution_637.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class Solution_637 {
    public List<Double> averageOfLevels(TreeNode root) {
        List<TreeNode> list  =  new LinkedList<>();
        List<Double> result  = new ArrayList<>();
        if (root==null){
            return null;
        }
        list.add(root);
        double temp = 0;
        while (!list.isEmpty()){
            int length = list.size();
            for (int i = 0; i <length ; i++) {
                TreeNode node = list.remove(0);
                temp += node.val;
                if (node.left!=null)
                    list.add(node.left);
                if (node.right!=null)
                    list.add(node.right);
            }
            result.add(temp/length);
            temp = 0;
        }
        return result;
    }
}
```
#### Solution_653.java
```java
package 数据结构相关.树;

import java.util.ArrayList;
import java.util.HashMap;

/**
 * @ClassName Solution_653
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_653 {
    public boolean findTarget(TreeNode root, int k) {
        return core(root,k,1);
    }
    // 缺少 两节点不在一个子树的情况 ,
    // 所以这一题不能用分别在左右子树两部分来处理这种思想，因为两个待求的节点可能分别在左右子树中。
    public boolean core(TreeNode root,int k ,int num){
        if (root == null){
            return  false;
        }
        if (root.val == k &&num ==2){
            return true;
        }
        return core(root.left,k,num)||core(root.right,k,num)||core(root.left,k - root.val,num+1)||core(root.right,k - root.val,num+1);
    }
    //中序遍历 + hashmap
    HashMap<Integer,Integer> map;
    public boolean findTarget2(TreeNode root, int k) {
        map = new HashMap<>();
        core2(root);
        for (Integer temp: map.keySet()) {
            System.out.println(temp+"  "+map.get(temp));
            if (temp == k - temp){
                if (map.get(temp)>=2){
                    return true;
                }
                else {
                    continue;
                }
            }
            else {
                if (map.containsKey(k-temp)){
                    return true;
                }
            }
        }
        return false;
    }
    public void core2(TreeNode root){
        if (root == null){
            return ;
        }
        core2(root.left);
        if (map.containsKey(root.val)){
            map.replace(root.val,map.get(root.val)+1);
        }
        else {
            map.put(root.val,1);
        }
        core2(root.right);
    }

    //中序遍历 + 数组 + 双指针
    public boolean findTarget3(TreeNode root, int k) {
        ArrayList<Integer> list = new ArrayList<>();
        core3(root,list);
        int i = 0;
        int j = list.size()-1;
        while (i<=j){
            if ((list.get(i)+list.get(j))==k){
                return true;
            }
            else if ((list.get(i)+list.get(j))<k){
                i++;
            }
            else {
                j--;
            }
        }
        return false;
    }
    public void core3(TreeNode root,ArrayList res){
        if (root == null){
            return ;
        }
        core3(root.left,res);
        res.add(root.val);
        core3(root.right,res);
    }

}

```
#### Solution_669.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_669
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_669 {
    public TreeNode trimBST(TreeNode root, int L, int R) {
        if (root==null){
            return root;
        }
        TreeNode treeNodel = trimBST(root.left, L, R);
        TreeNode treeNoder = trimBST(root.right, L, R);
        if (root.val>=L&&root.val<=R){
            root.left = treeNodel;
            root.right = treeNoder;
            return root;
        }
        if (treeNodel!=null){
            return treeNodel;
        }
        return treeNoder;
    }
}
```
#### Solution_671.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_671
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_671 {
    public int core(TreeNode root) {
        if (root.left==null&&root.right==null){
            return root.val;
        }

        int i = Math.min(root.left.val,root.right.val);
        if (root.val!=i){
            return i;
        }
        else if(root.val!=Math.max(root.left.val,root.right.val)){
            return Math.max(root.left.val,root.right.val);
        }
        else {
            int left = core(root.left);
            int right = core(root.right);
            int j = Math.min(left,right);
            int z = Math.max(left,right);
            if (root.val!=j){
                return j;
            }
            else if(root.val!=z){
                return z;
            }
            return -1;
         }
//        return root.val;
    }
    public int findSecondMinimumValue(TreeNode root) {
        if (root==null){
            return 0;
        }
        else if (root.left==null&&root.right==null){
            return -1;
        }
        return core(root);
    }
}
```
#### Solution_677.java
```java
package 数据结构相关.树;

import java.util.HashMap;
import java.util.Map;

/**
 * @ClassName Solution_677
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_677 {
}
class MapSum{
    int value ;
    MapSum[] mapSums = new MapSum[26];
    boolean isEnd = false;
    public MapSum() {
    }
    //前缀树
    public void insert(String key,int val,int index ){
        if (index<key.length()){
            if (mapSums[key.charAt(index)-'a']==null){
                mapSums[key.charAt(index)-'a'] = new MapSum();
            }
            if (index == key.length()-1){
                mapSums[key.charAt(index)-'a'].value = val;
                mapSums[key.charAt(index)-'a'].isEnd = true;
            }
            mapSums[key.charAt(index)-'a'].insert(key,val,index+1);
        }
    }
    public void insert(String key, int val) {
        MapSum temp = this;
        for (int i = 0; i < key.length(); i++) {
            if (temp.mapSums[key.charAt(i)-'a']==null){
                temp.mapSums[key.charAt(i)-'a'] = new MapSum();
            }
            temp = temp.mapSums[key.charAt(i)-'a'];
            if (i == key.length()-1){
                temp.isEnd=true;
                temp.value = val;
            }
        }
    }
    public int sum(String prefix) {
        MapSum temp = this;
        for (int i = 0; i < prefix.length(); i++) {
            if (temp.mapSums[prefix.charAt(i)-'a']==null){
                return 0;
            }
            temp = temp.mapSums[prefix.charAt(i)-'a'];
        }
        return  sumCore(temp);
    }
    public int sumCore(MapSum mapSum){
        if (mapSum == null){
            return 0;
        }
        int res = 0;
        if (mapSum.isEnd){
            res+=mapSum.value;
        }
        for (int i = 0; i < mapSum.mapSums.length; i++) {
            res += sumCore(mapSum.mapSums[i]);
        }
        return res;
    }
    // 在插入的过程中，直接将路径上的值进行叠加，  进行求和就不需要在进行递归遍历。
    class MapSum2 {
        HashMap<String, Integer> map;
        TrieNode root;
        public MapSum2() {
            map = new HashMap();
            root = new TrieNode();
        }
        public void insert(String key, int val) {
            int delta = val - map.getOrDefault(key, 0);
            map.put(key, val);
            TrieNode cur = root;
            cur.score += delta;
            for (char c: key.toCharArray()) {
                cur.children.putIfAbsent(c, new TrieNode());
                cur = cur.children.get(c);
                cur.score += delta;
            }
        }
        public int sum(String prefix) {
            TrieNode cur = root;
            for (char c: prefix.toCharArray()) {
                cur = cur.children.get(c);
                if (cur == null) return 0;
            }
            return cur.score;
        }
    }
    class TrieNode {
        Map<Character, TrieNode> children = new HashMap();
        int score;
    }
}
```
#### Solution_687.java
```java
package 数据结构相关.树;

/**
 * @ClassName Solution_687
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_687 {
    int sum = 0;
    public int longestUnivaluePath(TreeNode root) {
        isCore(root);
        return sum;
    }
    public int isCore(TreeNode root){
        if (root==null){
            return 0;
        }
        else {
            int left = isCore(root.left);
            int right = isCore(root.right);
            System.out.println(left+"   "+right+"   "+root.val);
            if (right==root.val&&left==root.val){
                sum =  Math.max(sum,left+right+1) ;
            }
            else if (right==root.val||left==root.val){
                sum = Math.max(sum,Math.max(left,right)+1);
            }
            else {
                sum =Math.max(sum, Math.max(left,right));
            }
            return root.val;
        }
    }


    private int path = 0;
    public int longestUnivaluePath2(TreeNode root) {
        dfs(root);
        return path;
    }
    private int dfs(TreeNode root){
        if (root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        int leftPath = root.left != null && root.left.val == root.val ? left + 1 : 0;
        int rightPath = root.right != null && root.right.val == root.val ? right + 1 : 0;
        path = Math.max(path, leftPath + rightPath);
        return Math.max(leftPath, rightPath);
    }
}
```
#### Solution_94.java
```java
package 数据结构相关.树;

import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;

/**
 * @ClassName Solution_94
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class Solution_94 {

    //二叉树的中序遍历次序 递归
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        core(root,res);
        return res;
    }
    private void core(TreeNode root, List<Integer> res) {
        if (root==null){
            return;
        }
        core(root.left,res);
        res.add(root.val);
        core(root.right,res);
    }
    public List<Integer> inorderTraversal3(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        if (root==null){
            return res;
        }
        LinkedList<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        TreeNode first = root;
        while (!stack.isEmpty()){
            while (first.left!=null){
                stack.push(first.left);
                first = first.left;
            }
            TreeNode pop = stack.pop();
            res.add(pop.val);
            if (pop.right!=null){
                stack.push(pop.right);
                first = pop.right;
            }
        }
        return res;
    }

    //颜色标记法  兼具栈迭代方法的高效，又像递归方法一样简洁易懂，
    // 更重要的是，这种方法对于前序、中序、后序遍历，能够写出完全一致的代码。
    public List<Integer> inorderTraversa3(TreeNode root) {
        LinkedList<Integer> res = new LinkedList<>();
        if (root==null){
            return res;
        }
        LinkedList<Flag> stack = new LinkedList<>();
        stack.push(new Flag(root,false));
        while (!stack.isEmpty()){
            Flag pop = stack.pop();
            if (pop.temp==null)
                continue;
            if (pop.flag==false){
                stack.push(new Flag(pop.temp.right,false));
                pop.flag = true;
                stack.push(pop);
                stack.push(new Flag(pop.temp.left,false));
            }
            else {
                res.add(pop.temp.val);
            }
        }
        return res;
    }
    //迭代实现   不正宗
    public List<Integer> inorderTraversal2(TreeNode root) {
        List<Integer> res = new LinkedList<>();
        LinkedList<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        HashSet<TreeNode> set = new HashSet<>();
        set.add(root);
        while (!stack.isEmpty()){
            TreeNode first = stack.getFirst();
            if (first.left!=null&&!set.contains(first.left)){
                stack.push(first.left);
                set.add(first.left);
            }
            else {
                TreeNode pop = stack.pop();
                set.add(pop);
                res.add(pop.val);
                if (pop.right!=null&&!set.contains(pop.right)){
                    stack.push(pop.right);
                    set.add(pop.right);
                }
            }
        }
        return res;
    }

    public static void main(String[] args) {

    }
}
class Flag{
    TreeNode temp;
    boolean flag;
    public Flag(TreeNode temp, boolean flag) {
        this.temp = temp;
        this.flag = flag;
    }
}
```
#### TreeNode.java
```java
package 数据结构相关.树;

/**
 * @ClassName TreeNode
 * @Description TODO
 * @Author DuanYueFeng
 * @Version 1.0
 **/
public class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;
    public TreeNode(int x) {
        val = x;
    }
}
```
